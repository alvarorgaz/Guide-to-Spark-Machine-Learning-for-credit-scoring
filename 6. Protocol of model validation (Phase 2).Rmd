---
title: "Guide to Spark Machine Learning for credit scoring"
author: "Álvaro Orgaz Expósito"
date: "29 June 2018"
output: html_document
---

# 6. PROTOCOL OF MODEL VALIDATION PHASE 2: Find the best parametrization of every model with training set

Create the vectors with the names of variables by types
```{r}
out <- c("Contract_ID","Postal_Code_ASNEF","Additional_Income","Partner_Income","Rent","Mortgage")
response <- c("Defaulted")
features_num <- c("Amount","Maturity","Postal_Code_ASNEF","Age","Seniority","Housing_Seniority",
                  "Income","Additional_Income","Rent","Partner_Income","Mortgage",
                  "Amount_of_Ongoing_Credits")
features_cat <- c("Application_Hour_Group","Application_Week_Day","Purpose","Province","Gender",
                  "Profession_Code","Profession_Sector","Contract_Type","Housing_Type",
                  "Marital_Status","People_in_Household","Num_Ongoing_Credits")
```

## 6.1 LOGISTIC REGRESSION

Starting time
```{r}
Sys.time()
```

Create the list of candidate parametrizations
```{r}
params <- list(features_num,features_cat,c(features_num,features_cat))
```

Iterate all candidate parametrizations
```{r}
results_cv_LR <- data.frame()
for(p in 1:length(params)){
  response_LR_global <- c()
  pred_LR_global <- c()

  # Iterate all training folds
  for(i in 1:K){
  
    # Create the training and test sets for the ith fold
    test_i <- train_partitions[[i]]
    train_i <- rbind(train_partitions[[c(1:K)[-i][1]]],train_partitions[[c(1:K)[-i][2]]],
                     train_partitions[[c(1:K)[-i][3]]],train_partitions[[c(1:K)[-i][4]]])
    
    # Train the model without ith fold and the pth parametrization
    model_LR_i <- ml_logistic_regression(train_i,
                                         response=response,
                                         features=params[[p]])
    
    # Predict ith fold with the pth parametrization
    pred_LR_i <- sdf_predict(test_i,model_LR_i)
        pred_LR_i <- data.frame(collect(pred_LR_i %>% select(probability_1)))[,"probability_1"]
    
    # Calculate the OOB AUC for the ith fold with the pth parametrization
    response_i <- data.frame(collect(test_i %>% select(Defaulted)))[,"Defaulted"]
    results_cv_LR[p,i] <- auc(roc(response_i,pred_LR_i))
    
    # Save the ith fold response and predictions with the pth parametrization
    response_LR_global <- c(response_LR_global,response_i)
    pred_LR_global <- c(pred_LR_global,pred_LR_i)
  }
  
  # Calculate the rest of performance measures with the global training set predicted as OOB
  quartile_cutoff <- quantile(pred_LR_global,seq(0.25,0.75,0.25))
  quartile <- ifelse(pred_LR_global<=quartile_cutoff[1],"Q1",
                        ifelse(pred_LR_global<=quartile_cutoff[2],"Q2",
                               ifelse(pred_LR_global<=quartile_cutoff[3],"Q3","Q4")))
  results_cv_LR[p,6] <- auc(roc(response_LR_global,pred_LR_global))
  results_cv_LR[p,7] <- mean(response_LR_global[quartile=="Q1"]==1)
  results_cv_LR[p,8] <- mean(response_LR_global[quartile=="Q2"]==1)
  results_cv_LR[p,9] <- mean(response_LR_global[quartile=="Q3"]==1)
  results_cv_LR[p,10] <- mean(response_LR_global[quartile=="Q4"]==1)
}
```

Print the results table
```{r}
row.names(results_cv_LR) <- c("Parametrization 1: numerical features",
                              "Parametrization 2: categorical features",
                              "Parametrization 3: all features")
names(results_cv_LR) <- c("AUC Fold 1","AUC Fold 2","AUC Fold 3","AUC Fold 4","AUC Fold 5",
                          "AUC Global","% True + Q1","% True + Q2","% True + Q3","% True + Q4")
save(results_cv_LR,file="results_cv_LR.RData")
results_cv_LR
```

Finishing time
```{r}
Sys.time()
```

## 6.2 DECISION TREE   #

Starting time
```{r}
Sys.time()
```

Create the list of candidate parametrizations
```{r}
max_bins <- c(10,20,30)
max_depth <- c(5,10,15)
min_instances_per_node <- c(5,9,13)
params <- expand.grid(max_bins,max_depth,min_instances_per_node)
params <- sapply(1:nrow(params),function(i){list(params[i,])})
```

Iterate all candidate parametrizations
```{r}
results_cv_DT <- data.frame()
for(p in 1:length(params)){
  response_DT_global <- c()
  pred_DT_global <- c()
  
  Iterate all training folds
  for(i in 1:K){
    
    # Create the training and test sets for the ith fold
    test_i <- train_partitions[[i]]
    train_i <- rbind(train_partitions[[c(1:K)[-i][1]]],train_partitions[[c(1:K)[-i][2]]],
                     train_partitions[[c(1:K)[-i][3]]],train_partitions[[c(1:K)[-i][4]]])
    
    # Train the model without ith fold and the pth parametrization
    model_DT_i <- ml_decision_tree(train_i,
                                   type="classification",
                                   response=response,
                                   features=c(features_num,features_cat),
                                   max_bins=as.numeric(params[[p]][1]),
                                   max_depth=as.numeric(params[[p]][2]),
                                   min_instances_per_node=as.numeric(params[[p]][3]),
                                   seed=1)
    
    # Predict ith fold with the pth parametrization
    pred_DT_i <- sdf_predict(test_i,model_DT_i)
    pred_DT_i <- data.frame(collect(pred_DT_i %>% select(probability_1)))[,"probability_1"]
    
    # Calculate the OOB AUC for the ith fold with the pth parametrization
    response_i <- data.frame(collect(test_i %>% select(Defaulted)))[,"Defaulted"]
    results_cv_DT[p,i] <- auc(roc(response_i,pred_DT_i))
    
    # Save the ith fold response and predictions with the pth parametrization
    response_DT_global <- c(response_DT_global,response_i)
    pred_DT_global <- c(pred_DT_global,pred_DT_i)
  }
  
  # Calculate the rest of performance measures with the global training set predicted as OOB
  quartile_cutoff <- quantile(pred_DT_global,seq(0.25,0.75,0.25))
  quartile <- ifelse(pred_DT_global<=quartile_cutoff[1],"Q1",
                     ifelse(pred_DT_global<=quartile_cutoff[2],"Q2",
                            ifelse(pred_DT_global<=quartile_cutoff[3],"Q3","Q4")))
  results_cv_DT[p,6] <- auc(roc(response_DT_global,pred_DT_global))
  results_cv_DT[p,7] <- mean(response_DT_global[quartile=="Q1"]==1)
  results_cv_DT[p,8] <- mean(response_DT_global[quartile=="Q2"]==1)
  results_cv_DT[p,9] <- mean(response_DT_global[quartile=="Q3"]==1)
  results_cv_DT[p,10] <- mean(response_DT_global[quartile=="Q4"]==1)
}
```

Print the results table
```{r}
row.names(results_cv_DT) <- sapply(1:length(params),function(i){
  paste0("max_bins=",params[[i]][1],";max_depth=",params[[i]][2],";min_instances_node=",
         params[[i]][3])})
names(results_cv_DT) <- c("AUC Fold 1","AUC Fold 2","AUC Fold 3","AUC Fold 4","AUC Fold 5",
                          "AUC Global","% True + Q1","% True + Q2","% True + Q3","% True + Q4")
save(results_cv_DT,file="results_cv_DT.RData")
results_cv_DT
```

Finishing time
```{r}
Sys.time()
```

## 6.3 RANDOM FOREST

Starting time
```{r}
Sys.time()
```

Create the list of candidate parametrizations
```{r}
max_bins <- c(10,20,30)
max_depth <- c(5,10,15)
num.trees <- c(15,30,45)
min_instances_per_node <- c(5,9,13)
params <- expand.grid(max_bins,max_depth,num.trees,min_instances_per_node)
params <- sapply(1:nrow(params),function(i){list(params[i,])})
```

Iterate all candidate parametrizations
```{r}
results_cv_RF <- data.frame()
for(p in 1:length(params)){
  response_RF_global <- c()
  pred_RF_global <- c()
  
  # Iterate all training folds
  for(i in 1:K){
    
    # Create the training and test sets for the ith fold
    test_i <- train_partitions[[i]]
    train_i <- rbind(train_partitions[[c(1:K)[-i][1]]],train_partitions[[c(1:K)[-i][2]]],
                     train_partitions[[c(1:K)[-i][3]]],train_partitions[[c(1:K)[-i][4]]])
    
    # Train the model without ith fold and the pth parametrization
    model_RF_i <- ml_random_forest(train_i,
                                   type="classification",
                                   response=response,
                                   features=c(features_num,features_cat),
                                   max_bins=as.numeric(params[[p]][1]),
                                   max_depth=as.numeric(params[[p]][2]),
                                   num_trees=as.numeric(params[[p]][3]),
                                   min_instances_per_node=as.numeric(params[[p]][4]),
                                   subsampling_rate=1,
                                   seed=1)
    
    # Predict ith fold with the pth parametrization
    pred_RF_i <- sdf_predict(test_i,model_RF_i)
    pred_RF_i <- data.frame(collect(pred_RF_i %>% select(probability_1)))[,"probability_1"]
    
    # Calculate the OOB AUC for the ith fold with the pth parametrization
    response_i <- data.frame(collect(test_i %>% select(Defaulted)))[,"Defaulted"]
    results_cv_RF[p,i] <- auc(roc(response_i,pred_RF_i))
    
    # Save the ith fold response and predictions with the pth parametrization
    response_RF_global <- c(response_RF_global,response_i)
    pred_RF_global <- c(pred_RF_global,pred_RF_i)
  }
  
  # Calculate the rest of performance measures with the global training set predicted as OOB
  quartile_cutoff <- quantile(pred_RF_global,seq(0.25,0.75,0.25))
  quartile <- ifelse(pred_RF_global<=quartile_cutoff[1],"Q1",
                     ifelse(pred_RF_global<=quartile_cutoff[2],"Q2",
                            ifelse(pred_RF_global<=quartile_cutoff[3],"Q3","Q4")))
  results_cv_RF[p,6] <- auc(roc(response_RF_global,pred_RF_global))
  results_cv_RF[p,7] <- mean(response_RF_global[quartile=="Q1"]==1)
  results_cv_RF[p,8] <- mean(response_RF_global[quartile=="Q2"]==1)
  results_cv_RF[p,9] <- mean(response_RF_global[quartile=="Q3"]==1)
  results_cv_RF[p,10] <- mean(response_RF_global[quartile=="Q4"]==1)
}
```

Print the results table 
```{r}
row.names(results_cv_RF) <- sapply(1:length(params),function(i){
  paste0("max_bins=",params[[i]][1],";max_depth=",params[[i]][2],";num_trees=",params[[i]][3],
         ";min_instances_node=",params[[i]][4])})
names(results_cv_RF) <- c("AUC Fold 1","AUC Fold 2","AUC Fold 3","AUC Fold 4","AUC Fold 5",
                          "AUC Global","% True + Q1","% True + Q2","% True + Q3","% True + Q4")
save(results_cv_RF,file="results_cv_RF.RData")
results_cv_RF
```

Finishing time
```{r}
Sys.time()
```

## 6.4 GRADIENT BOOSTED TREES

Starting time
```{r}
Sys.time()
```

Create the list of candidate parametrizations
```{r}
max_depth <- c(5,10,15)
max_iter <- c(15,30,45)
step_size <- c(0.05,0.1,0.15)
params <- expand.grid(max_depth,max_iter,step_size)
params <- sapply(1:nrow(params),function(i){list(params[i,])})
```

Iterate all candidate parametrizations
```{r}
results_cv_GBT <- data.frame()
for(p in 1:length(params)){
  response_GBT_global <- c()
  pred_GBT_global <- c()
  
  # Iterate all training folds
  for(i in 1:K){
    
    # Create the training and test sets for the ith fold
    test_i <- train_partitions[[i]]
    train_i <- rbind(train_partitions[[c(1:K)[-i][1]]],train_partitions[[c(1:K)[-i][2]]],
                     train_partitions[[c(1:K)[-i][3]]],train_partitions[[c(1:K)[-i][4]]])
    
    # Create the training and test sets for the ith fold in package "SparkR" format
    test_i_SparkR <- createDataFrame(sc_SparkR_sql,as.data.frame(collect(test_i)))
    train_i_SparkR <- createDataFrame(sc_SparkR_sql,as.data.frame(collect(train_i)))
    
    # Train the model without ith fold and the pth parametrization
    formula <- as.formula(paste(response,"~",paste(c(features_num,features_cat),collapse="+")))
    model_GBT_i <- spark.gbt(train_i_SparkR,
                             formula=formula,
                             type="classification",
                             maxDepth=as.numeric(params[[p]][1]),
                             maxIter=as.numeric(params[[p]][2]),
                             stepSize=as.numeric(params[[p]][3]),
                             subsamplingRate=1,
                             seed=1)
    
    # Predict ith fold with the pth parametrization
    pred_GBT_i <- predict(model_GBT_i,test_i_SparkR)
    pred_GBT_i <- unlist(lapply(as.data.frame(pred_GBT_i)[,"probability"],
                                function(x)SparkR:::callJMethod(x,"toArray")[[2]]))
    
    # Calculate the OOB AUC for the ith fold with the pth parametrization
    response_i <- data.frame(collect(test_i %>% select(Defaulted)))[,"Defaulted"]
    results_cv_GBT[p,i] <- auc(roc(response_i,pred_GBT_i))
    
    # Save the ith fold response and predictions with the pth parametrization
    response_GBT_global <- c(response_GBT_global,response_i)
    pred_GBT_global <- c(pred_GBT_global,pred_GBT_i)
  }
 
  # Calculate the rest of performance measures with the global training set predicted as OOB
  quartile_cutoff <- quantile(pred_GBT_global,seq(0.25,0.75,0.25))
  quartile <- ifelse(pred_GBT_global<=quartile_cutoff[1],"Q1",
                     ifelse(pred_GBT_global<=quartile_cutoff[2],"Q2",
                            ifelse(pred_GBT_global<=quartile_cutoff[3],"Q3","Q4")))
  results_cv_GBT[p,6] <- auc(roc(response_GBT_global,pred_GBT_global))
  results_cv_GBT[p,7] <- mean(response_GBT_global[quartile=="Q1"]==1)
  results_cv_GBT[p,8] <- mean(response_GBT_global[quartile=="Q2"]==1)
  results_cv_GBT[p,9] <- mean(response_GBT_global[quartile=="Q3"]==1)
  results_cv_GBT[p,10] <- mean(response_GBT_global[quartile=="Q4"]==1)
}
```

Print the results table
```{r}
row.names(results_cv_GBT) <- sapply(1:length(params),function(i){
  paste0("max_depth=",params[[i]][1],";max_iter=",params[[i]][2],
         ";step_size=",params[[i]][3])})
names(results_cv_GBT) <- c("AUC Fold 1","AUC Fold 2","AUC Fold 3","AUC Fold 4","AUC Fold 5",
                          "AUC Global","% True + Q1","% True + Q2","% True + Q3","% True + Q4")
save(results_cv_GBT,file="results_cv_GBT.RData")
results_cv_GBT
```

Finishing time
```{r}
Sys.time()
```

## 6.5 NAIVE BAYES

Starting time
```{r}
Sys.time()
```

Create the list of candidate parametrizations
```{r}
params <- list(features_num,features_cat,c(features_num,features_cat))
```

Iterate all candidate parametrizations
```{r}
results_cv_NB <- data.frame()
for(p in 1:length(params)){
  response_NB_global <- c()
  pred_NB_global <- c()
  
  # Iterate all training folds
  for(i in 1:K){
    
    # Create the training and test sets for the ith fold
    test_i <- train_partitions[[i]]
    train_i <- rbind(train_partitions[[c(1:K)[-i][1]]],train_partitions[[c(1:K)[-i][2]]],
                     train_partitions[[c(1:K)[-i][3]]],train_partitions[[c(1:K)[-i][4]]])
    
    # Train the model without ith fold and the pth parametrization
    model_NB_i <- ml_naive_bayes(train_i,
                                 response=response,
                                 features=params[[p]])
    
    # Predict ith fold with the pth parametrization
    pred_NB_i <- sdf_predict(test_i,model_NB_i)
    pred_NB_i <- data.frame(collect(pred_NB_i %>% select(probability_1)))[,"probability_1"]
    
    # Calculate the OOB AUC for the ith fold with the pth parametrization
    response_i <- data.frame(collect(test_i %>% select(Defaulted)))[,"Defaulted"]
    results_cv_NB[p,i] <- auc(roc(response_i,pred_NB_i))
    
    # Save the ith fold response and predictions with the pth parametrization
    response_NB_global <- c(response_NB_global,response_i)
    pred_NB_global <- c(pred_NB_global,pred_NB_i)
  }
  
  # Calculate the rest of performance measures with the global training set predicted as OOB
  quartile_cutoff <- quantile(pred_NB_global,seq(0.25,0.75,0.25))
  quartile <- ifelse(pred_NB_global<=quartile_cutoff[1],"Q1",
                     ifelse(pred_NB_global<=quartile_cutoff[2],"Q2",
                            ifelse(pred_NB_global<=quartile_cutoff[3],"Q3","Q4")))
  results_cv_NB[p,6] <- auc(roc(response_NB_global,pred_NB_global))
  results_cv_NB[p,7] <- mean(response_NB_global[quartile=="Q1"]==1)
  results_cv_NB[p,8] <- mean(response_NB_global[quartile=="Q2"]==1)
  results_cv_NB[p,9] <- mean(response_NB_global[quartile=="Q3"]==1)
  results_cv_NB[p,10] <- mean(response_NB_global[quartile=="Q4"]==1)
}
```

Print the results table
```{r}
row.names(results_cv_NB) <- c("Parametrization 1: numerical features",
                              "Parametrization 2: categorical features",
                              "Parametrization 3: all features")
names(results_cv_NB) <- c("AUC Fold 1","AUC Fold 2","AUC Fold 3","AUC Fold 4","AUC Fold 5",
                          "AUC Global","% True + Q1","% True + Q2","% True + Q3","% True + Q4")
save(results_cv_NB,file="results_cv_NB.RData")
results_cv_NB
```

Finishing time
```{r}
Sys.time()
```

## 6.6 NEURAL NETWORK

Starting time
```{r}
Sys.time()
```

Create the list of candidate parametrizations
```{r}
layer_hidden_1 <- c(6,8,10,12)
layer_hidden_2 <- c(4,6,8,10)
params <- expand.grid(layer_hidden_1,layer_hidden_2)
params <- sapply(1:nrow(params),function(i){list(params[i,])})
```

Iterate all candidate parametrizations
```{r}
results_cv_NN <- data.frame()
for(p in 1:length(params)){
  response_NN_global <- c()
  pred_NN_global <- c()
  
  # Iterate all training folds
  for(i in 1:K){
    
    # Create the training and test sets for the ith fold
    test_i <- train_partitions[[i]]
    train_i <- rbind(train_partitions[[c(1:K)[-i][1]]],train_partitions[[c(1:K)[-i][2]]],
                     train_partitions[[c(1:K)[-i][3]]],train_partitions[[c(1:K)[-i][4]]])
    
    # Create the training and test sets for the ith fold in package "SparkR" format
    test_i_SparkR <- createDataFrame(sc_SparkR_sql,as.data.frame(collect(test_i)))
    train_i_SparkR <- createDataFrame(sc_SparkR_sql,as.data.frame(collect(train_i)))
    
    # Establish the number of neurons:
    layer_output <- 2
    layer_hidden_1 <- as.numeric(params[[p]][1])
    layer_hidden_2 <- as.numeric(params[[p]][2])
    layer_input <- sum(sapply(as.data.frame(train_i_SparkR[,features_cat]),
                              function(x)length(unique(x))-1),length(features_num))
    
    # Train the model without ith fold and the pth parametrization
    formula <- as.formula(paste(response,"~",paste(c(features_num,features_cat),collapse="+")))
    model_NN_i <- spark.mlp(train_i_SparkR,
                            formula=formula,
                            layers=c(layer_input,layer_hidden_1,layer_hidden_2,layer_output),
                            seed=1)
    
    # Predict ith fold with the pth parametrization
    pred_NN_i <- predict(model_NN_i,test_i_SparkR)
    pred_NN_i <- unlist(lapply(as.data.frame(pred_NN_i)[,"probability"],
                               function(x)SparkR:::callJMethod(x,"toArray")[[2]]))
   
    # Calculate the OOB AUC for the ith fold with the pth parametrization
    response_i <- data.frame(collect(test_i %>% select(Defaulted)))[,"Defaulted"]
    results_cv_NN[p,i] <- auc(roc(response_i,pred_NN_i))
    
    # Save the ith fold response and predictions with the pth parametrization
    response_NN_global <- c(response_NN_global,response_i)
    pred_NN_global <- c(pred_NN_global,pred_NN_i)
  }
  
  # Calculate the rest of performance measures with the global training set predicted as OOB
  quartile_cutoff <- quantile(pred_NN_global,seq(0.25,0.75,0.25))
  quartile <- ifelse(pred_NN_global<=quartile_cutoff[1],"Q1",
                     ifelse(pred_NN_global<=quartile_cutoff[2],"Q2",
                            ifelse(pred_NN_global<=quartile_cutoff[3],"Q3","Q4")))
  results_cv_NN[p,6] <- auc(roc(response_NN_global,pred_NN_global))
  results_cv_NN[p,7] <- mean(response_NN_global[quartile=="Q1"]==1)
  results_cv_NN[p,8] <- mean(response_NN_global[quartile=="Q2"]==1)
  results_cv_NN[p,9] <- mean(response_NN_global[quartile=="Q3"]==1)
  results_cv_NN[p,10] <- mean(response_NN_global[quartile=="Q4"]==1)
}
```

Print the results table
```{r}
row.names(results_cv_NN) <- sapply(1:length(params),function(i){
  paste0("hidden_layer_1=",params[[i]][1],";hidden_layer_2=",params[[i]][2])})
names(results_cv_NN) <- c("AUC Fold 1","AUC Fold 2","AUC Fold 3","AUC Fold 4","AUC Fold 5",
                          "AUC Global","% True + Q1","% True + Q2","% True + Q3","% True + Q4")
save(results_cv_NN,file="results_cv_NN.RData")
results_cv_NN
```

Finishing time
```{r}
Sys.time()
```

Notes:

- **N8.** In the Multilayer Perceptron Neural Network, the number of neurons by layers are:
    
    - *output layer:* the # of classes in the response.
    
    - *hidden layers:* tunning parameters.

    - *input layer:* as much nodes as input variables. It means the # of numerical variables, plus the # of unique categories in all categorical variables, less the # of categorical features (because the model creates, for every categorical feature, dummies for every category except one for avoiding linear dependence).